#version 450

struct Onb {
    vec3 tangent;
    vec3 binormal;
    vec3 normal;
};

vec3 to_world(Onb onb, vec3 v) {
    return v.x * onb.tangent
         + v.y * onb.binormal
         + v.z * onb.normal;
}


struct Ray {
    vec3 origin;
    vec3 direction;
    float t_min;
    float t_max;
};

Ray make_ray(vec3 origin, vec3 direction, float t_min, float t_max) {
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.t_min = t_min;
    ray.t_max = t_max;
    return ray;
}

vec3 offset_ray_origin(vec3 p, vec3 n) {
    ivec3 of_i(256.0f * n, 256.0f * n, 256.0f * n);
    auto p_i = as<float3>(as<int3>(p) + ite(p < 0.0f, -of_i, of_i));
    return ite(abs(p) < 1.0f / 32.0f, p + 1.0f / 65536.0f * n, p_i);
}


struct Camera {
    vec3 position;
    vec3 front;
    vec3 up;
    vec3 right;
    float fov;
    uvec2 resolution;
};

Ray generate_ray(Camera camera, vec2 p) {
    float fov_radians = radians(camera.fov);
    float aspect_ratio = float(camera.resolution.x) / float(camera.resolution.y);
    vec3 wi_local(
        p.x * tan(0.5f * fov_radians) * aspect_ratio,
        p.y * tan(0.5f * fov_radians),
        -1.0f
    );
    vec3 wi_world = normalize(
        wi_local.x * camera.right
        + wi_local.y * camera.up
        - wi_local.z * camera.front
    );

    return make_ray(position, wi_world, 0.0f, 100000.0f);
}


struct SurfaceHitRecord {
    uint hit;
    float time;
};


struct Triangle {
    uint index0;
    uint index1;
    uint index2;
};

SurfaceHitRecord hit_triangle(
    Ray ray,
    vec3 p0, vec3 p1, vec3 p2,
    float t_min,
    float t_max
) {
    SurfaceHitRecord surface_hit_record;
    vec3 E1 = p1 - p0;
    vec3 E2 = p2 - p0;
    vec3 P = cross(ray.direction, E2);
    vec3 inv_det = 1.0f / dot(E1, P);

    vec3 T = ray.origin - p0;
    vec3 u = dot(T, P) * inv_det;
    if (u < 0.0f || u > 1.0f) {
        surface_hit_record.hit = false;
        return surface_hit_record
    }

    vec3 Q = cross(T, E1);
    vec3 v = dot(ray.direction, Q) * inv_det;
    if (v < 0.0f || u + v > 1.0f) {
        surface_hit_record.hit = false;
        return surface_hit_record
    }

    vec3 t = dot(E2, Q) * inv_det;
    if (t <= t_min || t >= t_max) {
        surface_hit_record.hit = false;
        return surface_hit_record
    }

    surface_hit_record.hit = true;
    surface_hit_record.time = t;

    return surface_hit_record
}

SurfaceHitRecord hit_scene(Ray ray, float t_min, float t_max) {
    SurfaceHitRecord surface_hit_record;
    surface_hit_record.hit = false;
    float t_closest = t_max;

    for (uint i = 0u; i < vertices.length(); i += 3u) {
        SurfaceHitRecord temp_record = hit_triangle(
            ray,
            vertices[i + 0u],
            vertices[i + 1u],
            vertices[i + 2u],
            t_min,
            t_max
        );
        if (temp_record.hit) {
            t_closest = temp_record.time;
            surface_hit_record = temp_record;
        }
    }

    return surface_hit_record;
}


uint tea(uint v0, uint v1) {
    uint s0 = 0u;
    for (uint n = 0u; n < 4u; ++n) {
        s0 += 0x9e3779b9u;
        v0 += ((v1 << 4) + 0xa341316cu) ^ (v1 + s0) ^ ((v1 >> 5u) + 0xc8013ea4u);
        v1 += ((v0 << 4) + 0xad90777du) ^ (v0 + s0) ^ ((v0 >> 5u) + 0x7e95761eu);
    }
    return v0;
};

float lcg(uint &state) {
    state = 1664525u * state + 1013904223u;
    return float(state & 0x00ffffffu) * (1.0f / float(0x01000000u));
};

vec3 cosine_sample_hemisphere(vec2 u) {
    float r = sqrt(u.x);
    float phi = 2.0f * constants::pi * u.y;
    return vec3(r * cos(phi), r * sin(phi), sqrt(1.0f - u.x));
};

float balanced_heuristic(float pdf_a, float pdf_b) {
    return pdf_a / max(pdf_a + pdf_b, 1e-4f);
};



struct DispatchData {
    uint spp;
    uint depths;
};

struct PushConstant {
    uint hittableCount;
    uint sample_start;
    uint samples;
    uint total_samples;
    uint max_depth;
};

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform PushConstant push_constants;

layout(set = 0, binding = 0, std140) uniform DispatchDataBuffer dispatch_data;
layout(set = 0, binding = 1, std140) uniform Camera camera;
layout(set = 0, binding = 2, rgba32f, std140) uniform image2D output_image;
layout(set = 0, binding = 3, r32ui, std140) uniform image2D seed_image;

layout(set = 1, binding = 0, std430) readonly buffer VerticesBuffer { vec3 data[]; } vertices;
layout(set = 1, binding = 1, std430) readonly buffer IndicesBuffer { Triangle data[]; } indices;


void main() {
    vec3 light_emission(17.0f, 12.0f, 4.0f);
    vec3 light_position(-0.24f, 1.98f, 0.16f);
    vec3 light_u = vec3(-0.24f, 1.98f, -0.22f) - light_position;
    vec3 light_v = vec3(0.23f, 1.98f, 0.16f) - light_position;
    float light_area = length(cross(light_u, light_v));
    vec3 light_normal = normalize(cross(light_u, light_v));

    uvec2 coord = gl_GlobalInvocationID.xy;
    uint state = imageLoad(seed_image, coord).r;

    float rx = lcg(state);
    float ry = lcg(state);
    vec2 pixel_coord(
        (float(coord.x) + rx) / float(camera.resolution.x) * 2.0f - 1.0f,
        // (float(coord.y) + ry) / float(camera.resolution.y) * 2.0f - 1.0f
        1.0f - (float(coord.y) + ry) / float(camera.resolution.y) * 2.0f
    );

    vec3 radiance(0.0f, 0.0f, 0.0f);
    for (uint i = 0; i < dispatch_data.spp; ++i) {
        Ray ray = generate_ray(camera, pixel_coord);
        vec3 beta(1.0f, 1.0f, 1.0f);
        float pdf_bsdf = 0.0f;
        for (uint depth = 0; depth < dispatch_data.depths; ++depth) {
            Var<SurfaceHit> hit = accel.intersect(ray, {});
            reorder_shader_execution();
            if (hit.miss()) { break; };
            Triangle triangle = heap.buffer<Triangle>(hit.inst).read(hit.prim);
            vec3 p0 = vertex_buffer.read(triangle.i0);
            vec3 p1 = vertex_buffer.read(triangle.i1);
            vec3 p2 = vertex_buffer.read(triangle.i2);
            vec3 p = triangle_interpolate(hit.bary, p0, p1, p2);
            vec3 n = normalize(cross(p1 - p0, p2 - p0));
            float cos_wo = dot(-ray.direction, n);
            if (cos_wo < 1e-4f) { break; };

            if (hit.inst == uint(meshes.size() - 1u)) {
                if (depth == 0u) {
                    radiance += light_emission;
                } else {
                    float pdf_light = length_squared(p - ray.origin) / (light_area * cos_wo);
                    float mis_weight = balanced_heuristic(pdf_bsdf, pdf_light);
                    radiance += mis_weight * beta * light_emission;
                };
                break;
            };

            float ux_light = lcg(state);
            float uy_light = lcg(state);
            vec3 p_light = light_position + ux_light * light_u + uy_light * light_v;
            vec3 pp = offset_ray_origin(p, n);
            vec3 pp_light = offset_ray_origin(p_light, light_normal);
            float d_light = distance(pp, pp_light);
            vec3 wi_light = normalize(pp_light - pp);
            Ray shadow_ray = make_ray(offset_ray_origin(pp, n), wi_light, 0.0f, d_light);
            bool occluded = accel.intersect_any(shadow_ray, {});
            float cos_wi_light = dot(wi_light, n);
            float cos_light = -dot(light_normal, wi_light);
            vec3 albedo = materials.read(hit.inst);
            if ((!occluded) && (cos_wi_light > 1e-4f) && (cos_light > 1e-4f)) {
                float pdf_light = (d_light * d_light) / (light_area * cos_light);
                float pdf_bsdf = cos_wi_light * inv_pi;
                float mis_weight = balanced_heuristic(pdf_light, pdf_bsdf);
                vec3 bsdf = albedo * inv_pi * cos_wi_light;
                radiance += beta * bsdf * mis_weight * light_emission / max(pdf_light, 1e-4f);
            };

            Onb onb = make_onb(n);
            float ux = lcg(state);
            float uy = lcg(state);
            vec3 wi_local = cosine_sample_hemisphere(vec2(ux, uy));
            float cos_wi = abs(wi_local.z);
            vec3 new_direction = onb->to_world(wi_local);
            ray = make_ray(pp, new_direction);
            pdf_bsdf = cos_wi * inv_pi;
            beta *= albedo;

            float l = dot(make_float3(0.212671f, 0.715160f, 0.072169f), beta);
            if (l == 0.0f) { break; };
            float q = max(l, 0.05f);
            float r = lcg(state);
            if (r >= q) { break; };
            beta *= 1.0f / q;
        };
    };

    radiance /= float(spp_per_dispatch);
    if (isnan(radiance)) { radiance = vec3(0.0f, 0.0f, 0.0f); };
    imageStore(output_image, coord, vec4(clamp(radiance, 0.0f, 30.0f), 1.0f));
    imageStore(seed_image, coord, uvec4(state));
};
